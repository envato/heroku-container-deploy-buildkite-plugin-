#!/bin/bash

set -ue

retry_sleep=$((${RETRY_SLEEP:-2} + 0))

if [ -z ${HEROKU_API_KEY:-} ]; then
  echo "Missing required HEROKU_API_KEY"
  exit 1
fi


function join_by { local IFS="$1"; shift; echo "$*"; }

function plugin_read_list() {
  prefix_read_list "BUILDKITE_PLUGIN_HEROKU_CONTAINER_DEPLOY_$1"
}

function prefix_read_list() {
  local prefix="$1"
  local parameter="${prefix}_0"

  if [[ -n "${!parameter:-}" ]]; then
    local i=0
    local parameter="${prefix}_${i}"
    while [[ -n "${!parameter:-}" ]]; do
      echo "${!parameter}"
      i=$((i+1))
      parameter="${prefix}_${i}"
    done
  elif [[ -n "${!prefix:-}" ]]; then
    echo "${!prefix}"
  fi
}

retry() {
  local retries=$1
  shift

  local count=0
  until "$@"; do
    exit=$?
    wait=$((retry_sleep ** count))
    count=$((count + 1))
    if [ $count -lt "$retries" ]; then
      echo "Retry $count/$retries exited $exit, retrying in $wait seconds..."
      sleep $wait
    else
      echo "Retry $count/$retries exited $exit, no more retries left."
      return $exit
    fi
  done
  return 0
}

app=$(plugin_read_list APP)
process_types=$(plugin_read_list PROCESS_TYPES)

function get_proc_type_image_tag() {
  echo "registry.heroku.com/$app/$1:latest"
}

##
## Pulling from owner container repo
##

function pull_prebuilt_images() {
  local proc_type=$1
  local proc_type_image=$2
  local proc_type_image_id
  proc_type_image_id=$(docker images -q "$proc_type_image")

  echo "~~~ :docker: Pulling $proc_type image"
  if [ -z "${proc_type_image_id}" ]; then
    local status=0
    if ! retry 3 docker pull "$proc_type_image"; then
      status=$((status + 1))
    fi
    if [ $status -eq 0 ]; then
      echo "Pulled $proc_type_image"
    else
      echo "Failed pull $proc_type_image"
      exit 1
    fi
  else
    echo "Found $proc_type_image"
  fi
}

##
## Tagging for heroku
##

for line in $process_types; do
  IFS=':' read -r -a tokens <<< "$line"
  pull_prebuilt_images "${tokens[@]}"
done

function tag_heroku_images() {
  local proc_type=$1
  local proc_type_image=$2
  local proc_type_tag; proc_type_tag=$(get_proc_type_image_tag "$proc_type")

  echo "~~~ :heroku: Tagging ${proc_type}"
  docker tag "$proc_type_image" "$proc_type_tag"
  echo "Tagged $proc_type_image as $proc_type_tag"
}

for line in $process_types; do
  IFS=':' read -r -a tokens <<< "$line"
  tag_heroku_images "${tokens[@]}"
done

##
## Pushing to heroku
##

echo "~~~ :heroku: Logging into Heroku Docker Registry"
echo "$HEROKU_API_KEY" | docker login --username=_ --password-stdin registry.heroku.com

function push_heroku_images() {
  local proc_type=$1
  local proc_type_image=$2
  local proc_type_tag; proc_type_tag=$(get_proc_type_image_tag "$proc_type")

  echo "~~~ :heroku: Pushing ${proc_type}"
  local status=0
  if ! retry 3 docker push "$proc_type_tag"; then
    status=$((status + 1))
  fi
  if [ $status -eq 0 ]; then
    echo "Pushed $proc_type_tag"
  else
    echo "Failed push $proc_type_tag"
    exit 1
  fi
}

for line in $process_types; do
  IFS=':' read -r -a tokens <<< "$line"
  push_heroku_images "${tokens[@]}"
done

##
## Releasing to heroku
##

proc_type_names=()
function get_proc_names() {
  local proc_type=$1
  proc_type_names+=("$proc_type")
}

for line in $process_types; do
  IFS=':' read -r -a tokens <<< "$line"
  get_proc_names "${tokens[@]}"
done


echo "~~~ :heroku: Releasing ${proc_type_names[*]}"

updates=()

function get_release_updates() {
  local proc_type=$1
  local proc_type_image=$2
  local proc_type_tag; proc_type_tag=$(get_proc_type_image_tag "$proc_type")
  local image_id; image_id=$(docker inspect "$proc_type_tag" --format={{.Id}})

  echo "Inspected $proc_type_tag identified as $image_id"
  updates+=("{\"type\":\"${proc_type}\",\"docker_image\":\"$image_id\"}")
}

for line in $process_types; do
  IFS=':' read -r -a tokens <<< "$line"
  get_release_updates "${tokens[@]}"
done

payload=$(join_by , "${updates[@]}")

echo "Updating formation"

curl -sf -X PATCH "https://api.heroku.com/apps/$app/formation" \
  -d "{\"updates\":[$payload]}" \
  -H "Content-Type: application/json" \
  -H "Accept: application/vnd.heroku+json; version=3.docker-releases" \
  -H "Authorization: Bearer ${HEROKU_API_KEY:-}"

echo "Verifying release"

version=""


function check_release() {
  local count=0
  local streamed=0
  while true;
  do
    count=$((count + 1))

    local latest_release; latest_release=$(curl -sf -X GET "https://api.heroku.com/apps/$app/releases" \
      -H "Content-Type: application/json" \
      -H "Accept: application/vnd.heroku+json; version=3" \
      -H "Range: version ..; max=1, order=desc" \
      -H "Authorization: Bearer ${HEROKU_API_KEY:-}")

    version=$(echo "$latest_release" | jq -r '.[0].version')
    local current; current=$(echo "$latest_release" | jq -r '.[0].current')
    local status; status=$(echo "$latest_release" | jq -r '.[0].status')
    local output_stream_url; output_stream_url=$(echo "$latest_release" | jq -r '.[0].output_stream_url')
    local summary; summary="[heroku version=$version, current=$current, status=$status]"

    if [ $streamed -eq 0 ] && [ "$status" == "pending" ] && [ "$output_stream_url" != "null" ]; then
      streamed=1
      echo "$summary releasing..."
      curl -sf -X GET "$output_stream_url"
      continue;
    fi

    if [ "$status" == "succeeded" ] && [ "$current" == "true" ]; then
      echo "$summary success"
      break;
    fi

    if [ "$status" == "failed" ]; then
      echo "$summary failure"
      exit 1
    fi

    if [ $count -gt 15 ]; then
      echo "$summary timeout"
      exit 1
    fi

    echo "$summary waiting..."
    sleep $retry_sleep;
  done
}

check_release

echo "Version $version is current :rocket:"
